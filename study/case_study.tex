\documentclass[12pt]{article}
\title{Case Study}
\usepackage{amsmath} %dfrac
\usepackage{graphicx}
\usepackage{epstopdf}

\begin{document}

\section{Methodology}

To characterize the behavior and estimate the benefit of the approach
proposed in this paper, a case study of representative tasks was
performed. The tasks were selected from Malardalen University of
Sweden's WCET benchmark suite[1]. Each task was built using Gaisler's
Bare-C Cross Compiler[2] for the GRSIM LEON3[3] simulated target. 

After compiling and linking, each task was analyzed by AbsInt's
a\textsuperscript{3} WCET[4] tool. This yielded the basic block
boundaries within each task. Next, the basic blocks
${\{B_1, B_2, ..., B_n\}}$ were serialized based upon an understanding of
the control flow of the task. Program points
${\{P_1, P_2, ..., P_n\}}$ were assigned by setting ${P_i}$ to the
address of the final instruction of each basic block ${B_i}$ for ${i}$
from ${0}$ to ${n}$.

Each program point ${P_j}$ served as a breakpoint within the task when
running on the simulator. The task was executed, recording the state of
the instruction ${C^I_j}$ and data ${C^D_j}$ cache state for every
visit of ${P_j}$. Given the limitations of the simulator and
a\textsuperscript{3} it was not possible record the actual control
flow. Thus, definitively over-estimating the UCBs shared between two
program points was not possible.

Instead, all instruction and data cache state was disregarded except
the state collected during the final visit of ${P_j}$ during the tasks
execution. Using these final snapshots the UCBs shared between two
program points ${P_i}$ and ${P_j}$ are determined by the following
equation. 
\begin{center}
  \begin{equation*}
    UCB(P_i, P_j) = \bigcap_{k=i}^{j-1} C_k
  \end{equation*}
  \emph{${C}$ may be either ${C^I}$ or ${C^D}$}
\end{center}

This intersection of the cache state taken from program point ${P_i}$
to the penultimate point ${P_{j-1}}$ serves as an upper bound on the
actual UCBs shared between the two points ${P_i}$ and ${P_j}$. Since
the UCBs are the primary factor of CRPD, the results are presented in
terms of UCB counts.

\subsection{Availability}

This method may be verified and reproduced using the same tools and
data. Gaisler's compiler and simulator are freely available. AbsInt's
a\textsuperscript{3} tool is available for educational and evaluation
purposes. The programs written and data used in this paper can be
found on GitHub at the following url:

\begin{center}
https://github.com/ctessler/superblocks/tree/master/study
\end{center}


\section{Results}

The results are presented as a comparison between the method described
herein and the Bertonga approach. For a program point ${P_j}$ the
Bertogna approach defines the UCBs (and therefor the CRPD) as:

\begin{equation*}
  max\{ UCB(P_i, P_j) \vert i < j \}
\end{equation*}

To determine the maximum benefit of the new approach, the best case
scenario is considered. When the preemption point is selected with the
fewest number of UCBs based upon previous preemption.  For ${P_j}$ the
determination is made by:

\begin{equation*}
  min\{ UCB(P_i, P_j) \vert i < j \}
\end{equation*}


In the following graphs, each point in the graph represents two points
in the program. The first point of the program ${P_i}$ is fixed by the
x-axis. Each point in the graph is labelled with a number, a later
program point ${P_j}$ which has been selected by the the Bertogna
approach, or by the proposed method. Bertogna's approach follows the
dashed blue line, the proposed approach the solid black line.

Bertogna's approach is represented by the dashed blue line. The proposed
approach by the solid black line. Both approaches will select two
program points, represented by a single position in the
graph. Bertogna's approach would select the lowest value of the dashed
blue line. The proposed approach would select the lowest value of the
solid black line. Comparing the number of shared UCBs allows a
comparison to be made.

\includegraphics{eps/bsort-icache.eps}

\includegraphics{eps/bsort-dcache.eps}

\includegraphics{eps/recursion-icache.eps}

\includegraphics{eps/recursion-dcache.eps}

%% An alternative for a wider graph
%% \includegraphics[width=\linewidth]{eps/fft1-icache.eps}

\includegraphics{eps/fft1-icache.eps}

\includegraphics{eps/fft1-dcache.eps}

For the bsort task, the proposed approach provides a benefit for the
instruction and data caches of 2 and 0 UCBs. For the fft1 task, the
instruction and data cache benefit is 121 and 7 UCBs. For the
recursion task, the benefit is 7 and 10 UCBs.

\section{References}

\begin{enumerate}
\item MRTC Benchmarks \\
http://www.mrtc.mdh.se/projects/wcet/benchmarks.html

\item Gaisler Compiler  \\
http://gaisler.com/index.php/downloads/compilers

\item Gaisler GRSIM \\
http://gaisler.com/index.php/products/simulators/grsim

\item AbsInt a\textsuperscript{3} WCET Tool \\
http://www.absint.com/a3/index.htm
\end{enumerate}


\end{document}

