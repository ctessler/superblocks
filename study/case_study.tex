\documentclass[12pt]{article}
\title{Case Study}
\usepackage{amsmath} %dfrac

\begin{document}

\section{Methodology}

To characterize the behavior and estimate the benefit of the approach
proposed in this paper, a case study of representative tasks was
performed. The tasks were selected from Malardalen University of
Sweden's WCET benchmark suite[1]. Each task was built using Gaisler's
Bare-C Cross Compiler[2] for the GRSIM LEON3[3] simulated target. 

After compiling and linking, each task was analyzed by AbsInt's
a\textsuperscript{3} WCET[4] tool. This yielded the basic block
boundaries within each task. Next, the basic blocks
${\{B_1, B_2, ..., B_n\}}$ were serialized based upon an understanding of
the control flow of the task. Program points
${\{P_1, P_2, ..., P_n\}}$ were assigned by setting ${P_i}$ to the
address of the final instruction of each basic block ${B_i}$ for ${i}$
from ${0}$ to ${n}$.

These program points served as a breakpoints within the task when
running on the simulator. During the execution of the task, the
instruction and data caches were collected at each breakpoint. Since
each breakpoint may be visited multiple times, the cache state was
only recorded for the final visit.

Taking the intersection of cache state at ${P_i}$ and ${P_j}$
serves as an overestimate of the actual UCBs for the ${B_i}$. These
UCB estimates can be used to determine the utility of the proposed
approach. 

\subsection{Availability}

This method may be verified and reproduced using the same tools and
data. Gaisler's compiler and simulator are freely available. AbsInt's
a\textsuperscript{3} tool is available for educational and evaluation
purposes. The programs written for this paper can be found on GitHub
at the following url:

\begin{center}
https://github.com/ctessler/superblocks/tree/master/study
\end{center}


\section{Results}

The results are presented as a comparison between the method described
herein and the Bertonga approach. For a program point ${P_j}$ the
Bertogna approach defines the UCBs (and therefor the CRPD) as:

\begin{equation*}
  max\{ UCB(P_i, P_j) \vert i < j \}
\end{equation*}

To determine the maximum benefit of the new approach, the best case
scenario is considered. When the preemption point is selected with the
fewest number of UCBs based upon previous preemption.  For ${P_j}$ the
determination is made by:

\begin{equation*}
  min\{ UCB(P_i, P_j) \vert i < j \}
\end{equation*}

The difference between these values is calculated for all program
points and then averaged. For the task set selected from the MRTC
Benchmark Suite, the average reduction in UCBs for instruction caches
is 41.40\% and data caches 2.28\%.

\section{References}

MRTC Benchmarks 
http://www.mrtc.mdh.se/projects/wcet/benchmarks.html


Gaisler GRSIM 
http://gaisler.com/index.php/products/simulators/grsim


Gaisler Compiler 
http://gaisler.com/index.php/downloads/compilers


\end{document}

