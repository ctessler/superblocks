\section{Preemption Point Placement Algorithm}\label{sec:implementation}

Our approach employs the results of schedulability analysis and the aforementioned WCET + CRPD calculation with the maximum allowable non-preemption region parameter \begin{math}Q_{i}\end{math} computed for each task \begin{math}\tau_{i}\end{math}.  The objective is to select a subset of preemption points that minimizes each tasks WCET + CRPD parameter \begin{math}C_{i}\end{math}. The selection of optimal preemption points is subject to the constraint that no non-preemptive region in task \begin{math}\tau_{i}\end{math} exceeds the maximum allowable non-preemption region parameter \begin{math}Q_{i}\end{math}:
\begin{equation}\label{eqn:pp-constraint}
   \Psi^{i}(\rho^{i}) =
\left\{
\begin{array}{lr}
    \textrm{True, }&\textrm{if } q_{m}^{i}(\rho^{i}) \leq Q_{i} \textrm{ for } m \in [1,|\rho^{i}|-1] \\
    \textrm{False, }&\textrm{otherwise}
\end{array}
\right\}~.
\end{equation}

\noindent
where \begin{math}q_{m}^{i}(\rho^{i})\end{math} represents the \begin{math}m^{th}\end{math} non-preemptive-region (NPR) time for task \begin{math}\tau_{i}\end{math}:
\begin{equation}\label{eqn:mthnpr-time}
   q_{m}^{i}(\rho^{i}) = \Big[\xi(\rho_{m}^{i},\rho_{m+1}^{i}) + \sum_{n=\rho_{m}^{i}}^{\rho_{m+1}^{i}}b_{n}^{i}\Big]
\end{equation}

\noindent
In accordance with the recursive nature of equation (\ref{eqn:bbkwcet-cost}) we propose an O(N!) recursive algorithm shown in Algorithm~\ref{alg:recursive-optimal-ppp} for computing the optimal preemption points.  While the recursive formulation is clearly inefficient, it is helpful in developing an understanding of how the algorithm works.  Starting with the first basic block and for each successive basic block \begin{math}\delta_{m}^{i}, m \in [1,N_{i}]\end{math}, the overall WCET cost is computed for two cases: 1) \begin{math}\delta_{m}^{i} \in \rho\end{math}, and 2) \begin{math}\delta_{m}^{i} \not\in \rho\end{math}.  At each step of the algorithm the set \begin{math}\rho\end{math} must conform to the constraint of equation (\ref{eqn:pp-constraint}).  Once basic block \begin{math}\delta_{N_{i}}^{i}\end{math} has been examined, the set of selected preemption points is given by \begin{math}\rho = \rho^{N_{i}}\end{math}.  The WCET cost with basic block \begin{math}\delta_{m}^{i}\end{math} included in the set of potential preemption points is given by:
\begin{equation}\label{eqn:pcost-bb}
p_{COST}(\delta_{m}^{i})\ =\ B_{0,m}^{i}(\rho^{i}) + B_{m,N_{i}}^{i}(\rho^{i})
\end{equation}

The WCET cost with basic block \begin{math}\delta_{m}^{i}\end{math} excluded from the set of potential preemption points is given by:
\begin{equation}\label{eqn:npcost-bb}
n_{COST}(\delta_{m}^{i})\ =\ B_{0,m-1}^{i}(\rho^{i}) + b_{m}^{i} + B_{m+1,N_{i}}^{i}(\rho^{i})
\end{equation}

\begin{algorithm}
\caption{Recursive Optimal Preemption Point Placement}
\label{alg:recursive-optimal-ppp}
\begin{algorithmic}[0]
\State \textbf{\underline{Step 0:}}
\\
\State {$\ \ \rho^{(0)}\ \gets\ \{\delta_{0}^{i},\delta_{N_{i}}^{i}\}$};
\State {$\ \ \textbf{if}\ \Psi_{N_{i}}^{i}(\{\delta_{0}^{i},\delta_{1}^{i},\delta_{2}^{i}, ..., \delta_{N_{i}}^{i}\}) = False$\ \textbf{then}}
\State {$\ \ \ \ \ \ \textbf{return}\ \textbf{INFEASIBLE;}$}
\State {$\ \ \textbf{end if}$}
\\
%\State \textbf{\underline{Step 1:}}
%\begin{equation*}
%\rho^{(1)}\ \gets\
%\left\{
%\begin{array}{l}
%    \rho^{(0)}, if\ n_{COST}(\delta_{1}^{i}) < p_{COST}(\delta_{1}^{i})\ \&\ \ \ \ \ \ \ \ \ \ \ \\
%    \ \ \ \ \ \ \ \ \ \ \Psi_{1}^{i}(\rho^{(0)}) = True\\
%    \rho^{(0)}\ \cup\ \delta_{1}^{i},\ otherwise
%\end{array}
%\right\}~.
%\end{equation*}
%\State \textbf{\underline{Step 2:}}
%\begin{equation*}
%\rho^{(2)}\ \gets\
%\left\{
%\begin{array}{l}
%    \rho^{(1)}, if\ n_{COST}(\delta_{2}^{i}) < p_{COST}(\delta_{2}^{i})\ \&\ \ \ \ \ \ \ \ \ \ \ \\
%    \ \ \ \ \ \ \ \ \ \ \Psi_{2}^{i}(\rho^{(1)}) = True\\
%    \rho^{(1)}\ \cup\ \delta_{2}^{i},\ otherwise
%\end{array}
%\right\}~.
%\end{equation*}
%\ldots
\State \textbf{\underline{Steps m = 1,\ \ldots,\ $N_{i}$:}}
\begin{equation*}
\rho^{(m)}\ \gets\
\left\{
\begin{array}{l}
    \rho^{(m-1)}, if\ n_{COST}(\delta_{m}^{i}) < p_{COST}(\delta_{m}^{i})\ \&\ \ \ \ \\
    \ \ \ \ \ \ \ \ \ \ \ \ \ \Psi_{m}^{i}(\rho^{(m-1)}) = True\\
    \rho^{(m-1)}\ \cup\ \delta_{m}^{i},\ otherwise
\end{array}
\right\}~.
\end{equation*}
%\ldots
%\State \textbf{\underline{Step $N_{i}$:}}
%\begin{equation*}
%\rho^{(N_{i})}\ \gets\
%\left\{
%\begin{array}{l}
%    \rho^{(N_{i}-1)}, if\ n_{COST}(\delta_{N_{i}}^{i}) < p_{COST}(\delta_{N_{i}}^{i})\ \&\\
%    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \Psi_{N_{i}}^{i}(\rho^{(N_{i}-1)}) = True\\
%    \rho^{(N_{i}-1)}\ \cup\ \delta_{N_{i}}^{i},\ otherwise
%\end{array}
%\right\}~.
%\end{equation*}
\end{algorithmic}
\end{algorithm}

\noindent
The recursive formulation gives a preliminary algorithm description, however, it is computationally intractable.  We now propose an \begin{math}O(cN^{2})\end{math} dynamic programming algorithm for computing the optimal preemption points.  The algorithm is summarized in Algorithm~\ref{alg:dynamic-optimal-ppp} shown below.  For each task $\tau_i$, we are given the following parameters: 1) the number of basic blocks $N_i$ , 2) the non-preemptive execution time of each basic block $b^i$, 3) the maximum allowable non-preemptive region $Q_i$, and 4) the preemption cost matrix $\xi$.  The preemption cost matrix $\xi$ is organized for each basic block \begin{math}\delta_{j}^{i}\end{math} and contains the preemption cost for all successor basic blocks of the task's control flow graph.  The minimum (preemptive or non-preemptive) cost between all basic blocks is computed and stored in a matrix denoted $B$.  The $B$ matrix is initially seeded with the non-preemptive cost for basic block pairs that satisfy the constraint $q(\delta_{j}^{i},\delta_{k}^{i}) < Q_{i}$. All other entries are set to infinity.  As we consider whether each basic block $\delta_{k}^{i}$ is in the set of optimal preemption points, the location of the previous basic block $\delta_{j}^{i}$ with minimal preemption cost is stored in an array denoted $\rho_{prev}$.  The algorithm examines each basic block from \begin{math}\delta_{1}^{i}\end{math} to \begin{math}\delta_{N_i}^{i}\end{math} to minimize the preemption cost by traversing backwards from the current basic block $\delta_{k}^{i}$ under consideration in order to find the basic block $\delta_{j}^{i}$ with minimal preemption cost subject to the constraint $q(\delta_{j}^{i},\delta_{k}^{i}) < Q_{i}$.  While each basic block will have a predecessor with minimum preemption cost, the list of selected preemption points is obtained by starting with basic block $\delta_{N_i}^{i}$ and hopping to the predecessor basic block stored at $\rho_{prev}(\delta_{N_i}^{i})$, denoted $\delta_{m}^{i}$.  Basic blocks $\delta_{N_i}^{i}$ and $\delta_{m}^{i}$ are added to the optimal preemption point set $\rho$.  This basic block hopping process continues until basic block $\delta_{0}^{i}$ is reached.  The set $\rho$ contains the complete list of selected optimal preemption points.

\begin{algorithm}
\caption{Dynamic Programming Optimal Preemption Point Placement}
\label{alg:dynamic-optimal-ppp}
\begin{algorithmic}[1]
\Function{$Select\_Optimal\_PPP$}{$N_{i}$,$b^{i}$,$Q_{i}$,$\xi$}
\State {$N_{p}\ \gets\ \infty\ q\ \gets\ \infty\ B\ \gets\ \infty\ \rho_{prev}\ \gets\ \{\delta_{0}^{i}\}$};
\If {$b_{k}^{i} > Q_{i}\ for\ some\ k\ \in\ [1,N_{i}]$}
\State\Return{INFEASIBLE;}
\EndIf
\For{$k: 2\leq k\leq N_{i}$}
\State\Call{$Compute\_PPCost$}{$\delta_{k-1}^{i}$,$\delta_{k}^{i}$};
\For{$j: k-1\geq j\geq 1\ and\ q(\delta_{j}^{i},\delta_{k}^{i}) < Q_{i}$}
%\Comment{$Check\ preemption\ cost\ at\ BB\ \delta_{j}^{i}\ with\ preemption$}
%\Comment{$at\ BB\ \delta_{0}^{i}\ and\ BB\ \delta_{k}^{i}$}
\State\Call{$Compute\_PPCost$}{$\delta_{0}^{i}$,$\delta_{j}^{i}$};
\State\Call{$Compute\_PPCost$}{$\delta_{j}^{i}$,$\delta_{k}^{i}$};
\State{$P_{cost}\ \gets\ B(\delta_{0}^{i},\delta_{j}^{i})\ +\ B(\delta_{j}^{i},\delta_{k}^{i})$};
\If {$P_{cost} < B(\delta_{0}^{i},\delta_{k}^{i})$}
\State{$B(\delta_{0}^{i},\delta_{k}^{i}) \gets P_{cost}$};
\State{$\rho_{prev}(\delta_{k}^{i}) \gets \delta_{j}^{i}$};
\EndIf
\EndFor
\EndFor
\State{$\rho\ \gets\ $\Call{$Compute\_PPSet$}{$N_{i},\rho_{prev}$}};
\State\Return{FEASIBLE;}
\EndFunction
\\
\Function{$Compute\_PPCost$}{$\delta_{j}^{i}$,$\delta_{k}^{i}$}
\If {$q(\delta_{j}^{i},\delta_{k}^{i})$ = $\infty$}
\State{$Compute\ \xi(\delta_{j}^{i}$,$\delta_{k}^{i})\ using\ Equation\ (\ref{eqn:prempt-cost})$};
\State{$Compute\ N_{p}(\delta_{j}^{i}$,$\delta_{k}^{i})$};
\State{$Compute\ q(\delta_{j}^{i}$,$\delta_{k}^{i})$};
\If {$q(\delta_{j}^{i}$,$\delta_{k}^{i})\ \leq\ Q_{i}$}
\State{$B(\delta_{j}^{i},\delta_{k}^{i}) \gets q(\delta_{j}^{i}$,$\delta_{k}^{i})$};
\State{$\rho_{prev}(\delta_{k}^{i}) \gets \delta_{j}^{i}$};
\Else
\If {$j-k\ =\ 1$}
\State\Return{INFEASIBLE;}
\EndIf
\EndIf
\EndIf
\EndFunction
\\
\Function{$Compute\_PPSet$}{$N_{i}$,$\rho_{prev}$}
\State {$\rho\ \gets\ \{\}$};
\State {$\rho_{index}\ \gets\ \{\delta_{N_{i}}^{i}\}$};
\While {$\rho_{index}\ \neq\ \delta_{0}^{i}$}
\State {$\rho\ \gets\ \rho\ \cup \rho_{index}$};
\State {$\rho_{index}\ \gets\ \rho_{prev}(\rho_{index})$};
\EndWhile
\State {$\rho\ \gets\ \rho\ \cup \rho_{index}$};
\State\Return{$\rho$;}
\EndFunction
\end{algorithmic}
\end{algorithm}

To exemplify how our algorithm works, consider the following example.