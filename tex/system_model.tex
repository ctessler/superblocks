\section{System Model}\label{sec:system_model}

Our system contains a task set \begin{math}\tau\end{math} of $n$ periodic or sporadic tasks (\begin{math}\tau_{1}\end{math}, \begin{math}\tau_{2}\end{math}, ..., \begin{math}\tau_{j}\end{math}, ..., \begin{math}\tau_{n}\end{math}) each scheduled on a single processor.  Each task \begin{math}\tau_{i}\end{math} is characterized by a tuple (\begin{math}\phi_{i}\end{math}, \begin{math}C_{i}^{NP}\end{math}, \begin{math}D_{i}\end{math}, \begin{math}T_{i}\end{math}, \begin{math}J_{i}\end{math}, \begin{math}P_{i}\end{math}) where \begin{math}\phi_{i}\end{math} is the starting time (also known as the phase), \begin{math}C_{i}^{NP}\end{math} is the non-preemptive worst case execution time, \begin{math}D_{i}\end{math} is the relative deadline, \begin{math}T_{i}\end{math} is the inter-arrival time or period, \begin{math}J_{i}\end{math} is the release jitter and \begin{math}P_{i}\end{math} is the uniquely assigned static fixed priority.  Each task \begin{math}\tau_{i}\end{math} creates an infinite number of jobs, with the first job arriving at starting time \begin{math}\phi_{i}\end{math} and subsequent jobs arriving no earlier than \begin{math}T_{i}\end{math} time units with a relative deadline \begin{math}D_{i}\end{math} \begin{math}\leq\end{math} \begin{math}T_{i}\end{math}.  The system utilizes a preemptive scheduler with each task/job containing \begin{math}N_{i}\end{math} number of basic blocks denoted (\begin{math}\delta_{i,1}\end{math}, \begin{math}\delta_{i,2}\end{math}, ..., \begin{math}\delta_{i,N_{i}}\end{math}) with the total number of basic blocks given by N = \begin{math}\Sigma_{i}\end{math} \begin{math}N_{i}\end{math}. In existing literature, basic blocks are denoted as \begin{math}\delta_{i,j}\end{math} where $i$ is the task identifier and $j$ is the basic block identifier denoting the basic block position in the control flow graph.  We introduce the notation \begin{math}\delta_{j}^{i}\end{math} where $i$ is the task identifier and $j$ is the basic block identifier. A basic block is a set of one or more instructions that execute non-preemptively.  Basic blocks are essentially the vertices $V$ of a control flow graph (CFG) connected by edges $E$ representing the execution sequence of job instructions. Preemptions are permitted at basic block boundaries.  Non-preemptive (NP) basic block execution time denoted as \begin{math}b_{i,j}\end{math} where $i$ is the task identifier and $j$ is the basic block identifier, where
\begin{equation}\label{eqn:c-np1}
    C_{i}^{NP} = \Sigma_{j}\ b_{i,j}.
\end{equation}
\noindent
We introduce the notation \begin{math}b_{j}^{i}\end{math} where $i$ is the task identifier and $j$ is the basic block identifier, hence using this convention we have
\begin{equation}\label{eqn:c-np2}
    C_{i}^{NP} = \Sigma_{j}\ b_{j}^{i}.
\end{equation}
\noindent
The task release jitter \begin{math}J_{i}\end{math} is defined as the maximum time between the task arriving for execution and it being released to a state of being ready to execute.  In our work, we assume the release jitter \begin{math}J_{i}\end{math} = 0.  The processor utilization \begin{math}U_{i}\end{math} of task \begin{math}\tau_{i}\end{math} is given by
\begin{equation}\label{eqn:u-task}
    U_{i} = C_{i}^{NP}/T_{i}.
\end{equation}
\noindent
Blocking time \begin{math}B_{i}\end{math} is the time which task \begin{math}\tau_{i}\end{math} is subject to accounting for the maximum time that a lower priority task either executes non-preemptively or holds a resource that is shared with task \begin{math}\tau_{i}\end{math} or any other task of equal or higher priority.

%In our work, we remove the restriction of a linear basic block structure thereby permitting an arbitrarily %connected basic block structure.  
A direct-mapped cache is assumed, though the techniques described here can be readily extended to set- associative caches. Tasks may be preempted by multiple higher-priority tasks identified by the variable $k$ where
\begin{equation}\label{eqn:hp-tasks}
    k \in hp(i) = \{k | P_{k} > P_{i}\}.
\end{equation}
\noindent
comprising the set of higher priority tasks for task \begin{math}\tau_{i}\end{math}.  This set needs to be filtered by tasks that must preempt during the execution window of task \begin{math}\tau_{i}\end{math}.  The number of times task \begin{math}\tau_{k}\end{math} can preempt task \begin{math}\tau_{i}\end{math} during task \begin{math}\tau_{i}\end{math}'s execution is given by the term
\begin{equation}\label{eqn:num-preemptions}
    N_{p}(\tau_{i},\tau_{k})=\lceil(C_{i}^{NP} + J_{k})/T_{k})\rceil \geq 1.
\end{equation}
\noindent
where $k$ is the index of the preempting task \begin{math}\tau_{k}\end{math} and $i$ is the index of the preempted task \begin{math}\tau_{i}\end{math}.  In a limited preemption approach, each task is permitted to execute non-preemptively for a maximum amount of time denoted by \begin{math}Q_{i}\end{math}.  The following figure shown below illustrates the linear basic block connection structure \begin{math}\delta_{i,b}\end{math} also denoted as \begin{math}\delta_{b}^{i}\end{math} using our convention.

